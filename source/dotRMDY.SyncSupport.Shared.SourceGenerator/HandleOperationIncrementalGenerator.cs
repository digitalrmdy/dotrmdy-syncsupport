using System.Collections.Immutable;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace dotRMDY.SyncSupport.Shared.SourceGenerator;

[Generator]
public class HandleOperationIncrementalGenerator : IIncrementalGenerator
{
	private const string OPERATION_HANDLER_UNBOUND_BASETYPE_FULLNAME = "dotRMDY.SyncSupport.Shared.Handlers.IOperationHandler`1";
	private const string OPERATION_HANDLER_SERVICE_BASETYPE_FULLNAME = "dotRMDY.SyncSupport.Shared.Services.Implementations.OperationHandlerService";

	private static readonly AssemblyName _assemblyName = typeof(HandleOperationIncrementalGenerator).Assembly.GetName();
	private static readonly string _generatedCodeAttribute = $@"[System.CodeDom.Compiler.GeneratedCode(""{_assemblyName.Name}"", ""{_assemblyName.Version}"")]";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var operationHandlerUnboundBaseTypeSymbolValueProvider =
			context.CompilationProvider.Select(static (compilation, ct) => compilation.GetTypeByMetadataName(OPERATION_HANDLER_UNBOUND_BASETYPE_FULLNAME));
		var operationHandlerServiceBaseTypeSymbolValueProvider =
			context.CompilationProvider.Select(static (compilation, ct) => compilation.GetTypeByMetadataName(OPERATION_HANDLER_SERVICE_BASETYPE_FULLNAME));

		var baseSyntaxNodeIncrementalValuesProvider = context.SyntaxProvider.CreateSyntaxProvider(
				IsSyntaxForGeneration,
				Step1FilterGeneric)
			.Where(x => x != null);

		var operationHandlerIncrementalValuesProvider = baseSyntaxNodeIncrementalValuesProvider
			.Select(Step2FilterAndTransformForOperationHandlers)
			.Where(x => x != null)
			.Combine(operationHandlerUnboundBaseTypeSymbolValueProvider)
			.Select(Step3FilterForOperationHandlers)
			.Where(x => x != null);

		var operationHandlerServiceIncrementalValuesProvider = baseSyntaxNodeIncrementalValuesProvider
			.Combine(operationHandlerServiceBaseTypeSymbolValueProvider)
			.Select(Step2FilterAndTransformForOperationHandlerServices)
			.Where(x => x != null)
			.Collect();

		var tadaam = operationHandlerServiceIncrementalValuesProvider.Combine(operationHandlerIncrementalValuesProvider.Collect());

		context.RegisterSourceOutput(tadaam, (productionContext, sourceInput) =>
		{
			var operationHandlerServiceTypeInfo = sourceInput.Left.First()!.Value;
			var operationTypeInfo = sourceInput.Right;

			var operationHandlerServiceSourceCode =
				$$"""
				  // <auto-generated/>

				  namespace {{operationHandlerServiceTypeInfo.@namespace}}
				  {
				      {{_generatedCodeAttribute}}
				      public partial class {{operationHandlerServiceTypeInfo.classname}}
				      {
				          protected override global::System.Threading.Tasks.Task<global::dotRMDY.SyncSupport.Shared.Models.CallResult> HandleOperationRaw(global::dotRMDY.SyncSupport.Shared.Models.Operation operation)
				          {
				              switch (operation)
				              {
				                  {{string.Join("\n", operationTypeInfo
					                  .OfType<(string fullyQualifiedTypeName, string typeName)>()
					                  .Select(x => GenerateSwitchCase(x.fullyQualifiedTypeName, x.typeName)))}}
				                  default:
				                      return base.HandleOperationRaw(operation);
				              }
				          }
				      }
				  }
				  """;

			static string GenerateSwitchCase(string fullyQualifiedTypeName, string typeName) =>
				$@"case {fullyQualifiedTypeName} {typeName}:
					return HandleOperation({typeName});";

			productionContext.AddSource($"{operationHandlerServiceTypeInfo.@namespace}.{operationHandlerServiceTypeInfo.classname}.g.cs",
				SourceText.From(operationHandlerServiceSourceCode, Encoding.UTF8));
		});
	}

	private static bool IsSyntaxForGeneration(SyntaxNode syntaxNode, CancellationToken cancellationToken)
	{
		if (syntaxNode is not ClassDeclarationSyntax classDeclarationSyntax)
		{
			return false;
		}

		return classDeclarationSyntax.BaseList?.Types.Count > 0;
	}

	private static INamedTypeSymbol? Step1FilterGeneric(GeneratorSyntaxContext syntaxContext, CancellationToken ct)
	{
		var semanticModel = syntaxContext.SemanticModel;
		var classDeclarationSyntax = (ClassDeclarationSyntax) syntaxContext.Node;

		if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not INamedTypeSymbol concreteClassSymbol || concreteClassSymbol.IsAbstract)
		{
			return null;
		}

		return concreteClassSymbol;
	}

	private static (INamedTypeSymbol concreteClassSymbol, ImmutableArray<INamedTypeSymbol> allTypeInterfaces)? Step2FilterAndTransformForOperationHandlers(
		INamedTypeSymbol? concreteClassSymbol, CancellationToken ct)
	{
		var allTypeInterfaces = concreteClassSymbol!.AllInterfaces;
		if (allTypeInterfaces.Length == 0)
		{
			return null;
		}

		return (concreteClassSymbol, allTypeInterfaces);
	}

	private static (string fullyQualifiedOperationTypeName, string operationTypeName)? Step3FilterForOperationHandlers(
		((INamedTypeSymbol concreteClassSymbol, ImmutableArray<INamedTypeSymbol> allTypeInterfaces)? Left, INamedTypeSymbol? Right) valueTuple,
		CancellationToken ct)
	{
		var (concreteClassSymbolInfo, baseTypeSymbol) = valueTuple;
		// TODO: Omit unused parameter from pipeline
		var (_, specializedImplementedInterfaces) = concreteClassSymbolInfo!.Value;

		var operationHandlerOfTTypeSymbol = specializedImplementedInterfaces.FirstOrDefault(implementedInterface =>
			SymbolEqualityComparer.Default.Equals(implementedInterface.OriginalDefinition, baseTypeSymbol!));
		if (operationHandlerOfTTypeSymbol == null)
		{
			return null;
		}

		var operationTypeSymbol = operationHandlerOfTTypeSymbol.TypeArguments[0];
		var fullyQualifiedTypeName = operationTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

		var typeName = operationTypeSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
		typeName = char.ToLowerInvariant(typeName[0]) + typeName.Substring(1);

		return (fullyQualifiedTypeName, typeName);
	}

	private static (string @namespace, string classname)? Step2FilterAndTransformForOperationHandlerServices(
		(INamedTypeSymbol? Left, INamedTypeSymbol? Right) valueTuple, CancellationToken cancellationToken)
	{
		var (concreteClassTypeSymbol, baseTypeSymbol) = valueTuple;

		var currentBaseTypeSymbol = concreteClassTypeSymbol!.BaseType;
		while (currentBaseTypeSymbol != null && currentBaseTypeSymbol.SpecialType != SpecialType.System_Object)
		{
			if (SymbolEqualityComparer.Default.Equals(currentBaseTypeSymbol, baseTypeSymbol!))
			{
				return (concreteClassTypeSymbol.ContainingNamespace.ToDisplayString(), concreteClassTypeSymbol.Name);
			}

			currentBaseTypeSymbol = currentBaseTypeSymbol.BaseType;
		}

		return null;
	}
}